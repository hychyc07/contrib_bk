// Class automatically generated by Dev-C++ New Class wizard

#ifndef ROBOT_H
#define ROBOT_H

#include <iCub/kinematics/robmatrix.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>

/*
 * Generic class to compute robot kinematics
 *
 * \author Manuel Lopes
 *
 */
class Robot
{
	/* TODO (#1#): adicionar a ferramenta a classe robot */
	public:
		RobMatrix frametransf(int joint, double value);
		// class constructor
		Robot(int njoints);
		/**
		 * Set the Modified Denavitt Hartenberg parameters
		 */
		void SetJoint(int joint, float al, float a, float th, float d);
        void SetJoint(int joint, float al, float a, float th, float d, float lolim, float uplim);
		/**
		 * Forward kinematics
		 */
		RobMatrix fk(double *th);
		RobMatrix fk(double *th, int joint);
		/**
		 * Jacobian evaluation
		 */
		void Jacobn(double* pos, double *J);
        void Jacob0(double* pos, double *J);
		void Jacob0(double* pos, gsl_matrix* J);

        double JacobInv0(double* pos, gsl_matrix* Jinv, float tol);
        void V2Qdot(double* pos, double* V, gsl_vector* qdot, float tol);
        void V2Qdot(double* pos, gsl_vector* V, gsl_vector* qdot, float tol);
        // class destructor
		~Robot();

		int Getm_njoints(); // returns the value of m_njoints
		/**
		 * Validates the position of the robot.
		 * Returns:
		 * 0 if a valid position
		 * x if the joint x is above the upper limit
		 * -x if the joint x is below the lower limit
		 */
		int ValidPosition(double *pos);
		int ValidPosition(gsl_vector *pos);

RobMatrix* m_Joints;
	private:
		/**
		 * List of joints, the same size has m_njoints
		 */
//		RobMatrix* m_Joints;
		/**
		 * Number of joints
		 */
		int m_njoints;
		float* m_uplimit;
		float* m_lolimit;

};

#endif // ROBOT_H
